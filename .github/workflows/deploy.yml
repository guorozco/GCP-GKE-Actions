name: Deploy Hello World Flask App

on:
  push:
    branches: [main, develop]
    tags: ['v*']
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_approval:
        description: 'Skip manual approval for production'
        required: false
        default: false
        type: boolean

env:
  PROJECT_ID: test-demo-123456-guillermo
  STAGING_REGISTRY: us-central1-docker.pkg.dev/test-demo-123456-guillermo/staging-docker
  PRODUCTION_REGISTRY: us-east1-docker.pkg.dev/test-demo-123456-guillermo/production-docker
  IMAGE_NAME: hello-world-flask
  STAGING_CLUSTER: gke-staging
  STAGING_REGION: us-central1
  PRODUCTION_CLUSTER: gke-production
  PRODUCTION_REGION: us-east1

jobs:
  # Stage 1: Build and Push Docker Image
  build:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    
    outputs:
      image-staging: ${{ steps.image-info.outputs.image-staging }}
      image-production: ${{ steps.image-info.outputs.image-production }}
      version: ${{ steps.image-info.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          
      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker us-central1-docker.pkg.dev,us-east1-docker.pkg.dev
          
      - name: Set image information
        id: image-info
        run: |
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" =~ refs/tags/v.* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=${GITHUB_SHA::8}
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "image-staging=${{ env.STAGING_REGISTRY }}/${{ env.IMAGE_NAME }}:$VERSION" >> $GITHUB_OUTPUT
          echo "image-production=${{ env.PRODUCTION_REGISTRY }}/${{ env.IMAGE_NAME }}:$VERSION" >> $GITHUB_OUTPUT
          
      - name: Build and push to staging registry
        run: |
          cd app
          docker build \
            --tag ${{ steps.image-info.outputs.image-staging }} \
            --label "org.opencontainers.image.source=${{ github.repositoryUrl }}" \
            --label "org.opencontainers.image.revision=${{ github.sha }}" \
            --label "org.opencontainers.image.version=${{ steps.image-info.outputs.version }}" \
            .
          docker push ${{ steps.image-info.outputs.image-staging }}
          
      - name: Build and push to production registry (on tag)
        if: startsWith(github.ref, 'refs/tags/v')
        run: |
          cd app
          docker build \
            --tag ${{ steps.image-info.outputs.image-production }} \
            .
          docker push ${{ steps.image-info.outputs.image-production }}

  # Stage 2: Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
    
    environment:
      name: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        
      - name: Install gke-gcloud-auth-plugin
        run: gcloud components install gke-gcloud-auth-plugin
          
      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.12.0'
          
      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.STAGING_CLUSTER }} \
            --region=${{ env.STAGING_REGION }} \
            --project=${{ env.PROJECT_ID }}
            
      - name: Deploy to staging with Helm
        run: |
          helm upgrade --install hello-app-staging ./charts/hello-app \
            --namespace default \
            --values ./charts/hello-app/values-staging.yaml \
            --set image.repository=${{ env.STAGING_REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ needs.build.outputs.version }} \
            --set app.version=${{ needs.build.outputs.version }} \
            --wait \
            --timeout=10m
            
      - name: Clean up old deployments
        run: |
          # Remove old deployments that might conflict
          kubectl delete deployment hello-world-flask --ignore-not-found=true
          kubectl delete service hello-world-flask-service --ignore-not-found=true
          kubectl delete hpa hello-world-flask-hpa --ignore-not-found=true
          
      - name: Run health checks
        run: |
          # Wait for Helm deployment pods to be ready
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=hello-app-staging --timeout=300s
          
          # Get service name and test connectivity
          STAGING_SERVICE="hello-app-staging-hello-app"
          
          # Try to get external IP first, fallback to port-forward
          EXTERNAL_IP=$(kubectl get service $STAGING_SERVICE -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
          if [[ -n "$EXTERNAL_IP" && "$EXTERNAL_IP" != "null" && "$EXTERNAL_IP" != "" ]]; then
            echo "Testing via external IP: $EXTERNAL_IP"
            for i in {1..30}; do
              if curl -f "http://$EXTERNAL_IP/api/health"; then
                echo "Staging health check passed via external IP!"
                break
              fi
              echo "Waiting for external service... ($i/30)"
              sleep 10
            done
          else
            echo "External IP not available, using port-forward"
            kubectl port-forward service/$STAGING_SERVICE 8080:80 &
            PF_PID=$!
            sleep 5
            curl -f http://localhost:8080/api/health
            kill $PF_PID
            echo "Staging health check passed via port-forward!"
          fi

  # Stage 3: Manual Approval for Production
  approve:
    name: Manual Approval for Production
    runs-on: ubuntu-latest
    needs: [build, deploy-staging]
    if: startsWith(github.ref, 'refs/tags/v') && github.event.inputs.skip_approval != 'true'
    
    environment:
      name: production-approval
      
    steps:
      - name: Require manual approval
        run: |
          echo "Manual approval required for production deployment"
          echo "Version: ${{ needs.build.outputs.version }}"
          echo "Waiting for approval in GitHub Environment..."

  # Stage 4: Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, deploy-staging, approve]
    if: |
      always() && 
      (needs.approve.result == 'success' || (startsWith(github.ref, 'refs/tags/v') && github.event.inputs.skip_approval == 'true')) &&
      needs.build.result == 'success' &&
      needs.deploy-staging.result == 'success'
    
    environment:
      name: production
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        
      - name: Install gke-gcloud-auth-plugin
        run: gcloud components install gke-gcloud-auth-plugin
          
      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.12.0'
          
      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.PRODUCTION_CLUSTER }} \
            --region=${{ env.PRODUCTION_REGION }} \
            --project=${{ env.PROJECT_ID }}
            
      - name: Deploy to production with Helm
        run: |
          VERSION=${{ needs.build.outputs.version }}
          
          helm upgrade --install hello-app-production ./charts/hello-app \
            --namespace default \
            --values ./charts/hello-app/values-production.yaml \
            --set image.repository=${{ env.PRODUCTION_REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=$VERSION \
            --set app.version=$VERSION \
            --wait \
            --timeout=15m
            
      - name: Clean up old deployments
        run: |
          # Remove old deployments that might conflict
          kubectl delete deployment hello-world-flask --ignore-not-found=true
          kubectl delete service hello-world-flask-service --ignore-not-found=true
          kubectl delete hpa hello-world-flask-hpa --ignore-not-found=true
          
      - name: Run production health checks
        run: |
          # Wait for Helm deployment pods to be ready
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=hello-app-production --timeout=600s
          
          # Get service name and test connectivity
          PRODUCTION_SERVICE="hello-app-production-hello-app"
          
          # Try to get external IP, fallback to port-forward
          EXTERNAL_IP=$(kubectl get service $PRODUCTION_SERVICE -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
          if [[ -n "$EXTERNAL_IP" && "$EXTERNAL_IP" != "null" && "$EXTERNAL_IP" != "" ]]; then
            echo "Testing via external IP: $EXTERNAL_IP"
            for i in {1..30}; do
              if curl -f "http://$EXTERNAL_IP/api/health"; then
                echo "Production health check passed via external IP!"
                break
              fi
              echo "Waiting for external service... ($i/30)"
              sleep 10
            done
          else
            echo "External IP not available, using port-forward"
            kubectl port-forward service/$PRODUCTION_SERVICE 8080:80 &
            PF_PID=$!
            sleep 5
            curl -f http://localhost:8080/api/health
            kill $PF_PID
            echo "Production health check passed via port-forward!"
          fi